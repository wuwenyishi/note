# 小数转二进制的过程

**示例一**

4.25转为二进制的过程：

拆分为整数部分和小数部分，整数部分为4，小数部分为0.25。

4转二进制为：100

0.25转二进制为：0.01

将两个二进制相加就是：100.01，所以4.25的转为二进制就是100.01

0.25转二进制的过程：

0.25*2=0.5，取整数为0

0.5*2=1.0，取整数为1

这时小数部分为0时结束，0.25的二进制的小数部分就是01。



**示例二**

19.625转为二进制过程：

19转二进制为：10011

0.625转二进制的过程：

0.625*2=1.25，取整数部分 1

0.25*2=0.5，取整数部分 0

0.5*2=1.0，取整数部分 1

这时小数部分为0，结束。

0.625的二进制就表示为：0.101

19.625的二进制表示为：10011.101



# 小数在计算机中的存储形式

C语言中，对于浮点类型的数据采用单精度类型`（float）`和双精度类型`(double)`来存储，`float`数据占用32bit, `double`数据占用64bit。

无论是单精度还是双精度在存储中都分为三个部分：

- **符号位(Sign)** : 0代表正，1代表为负
- **指数位（Exponent）**: 用于存储科学计数法中的指数数据，并且采用移位存储
- **尾数部分（Mantissa）**：尾数部分

![](https://xuemingde.com/pages/image/2022/11/11/1009586PctKl.png)

* 符号的存储

 符号的存储很容易，就像存储 short、int 等普通整数一样，单独分配出一个位（Bit）来，**用 0 表示正数，用 1 表示负数**。对于 19.625，这一位的值是 0。

* 尾数的存储

 计算机采用二进制形式存储浮点数，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：**尾数的整数部分一定为 1，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉**，**只要把小数点后面的二进制数字放入内存中即可**。对于 1.0011101，就是把 0011101 放入内存。

> 19.625的二进制为10011.101，也可表示为1.0011101 * 2^4^，所以19.625的尾数部分为1.0011101

>4.6的二进制为100.1001100110011001…….,小数部分出现了死循环，所有有无数位，100.1001100110011001…….可转为1.001001100110011001……. * 2^2^,又因为float的尾数部分为23bit，所以会截取23个存储，这时就出现了精度丢失。
>
>`double`为64bit，尾数部分占52bit，虽然提高了精度，但也不能完全保证一致。





* 指数的存储

> 指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。
>  **先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。**

`float 的指数部分占用 8 Bits，能表示从 0~255 的值，取其中间值 127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了`。

`而对于指数部分，因为指数可正可负(占1位)，所以8位的指数位能表示的指数范围就只能用7位，范围是:-127至128。所以指数部分的存储采用移位存储，存储的数据为元数据 +127。`

19.625 的二进制为10011.101，可表示为1.0011101 * 2^4^，所以他的指数为4（就是2的多少次方），4+127=131，131的二进制为10000011，所以19.625的指数部分存储的为10000011

> `double`的指数部分为11



结束上述的描述，19.625  float 的存储形式为：

| 符号位  | 指数为      | 尾数部分                         |
| ---- | -------- | ---------------------------- |
| 0    | 10000011 | 001 1101 0000 0000 0000 0000 |

> float的尾数部分为23bit，0011101只用了7bit，后面的补0，补刀23bit为止





